# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/02_generator.ipynb (unless otherwise specified).

__all__ = ['UNASSIGNED', 'VOID', 'SOLID', 'PIXEL_IMPOSSIBLE', 'PIXEL_EXISTING', 'PIXEL_POSSIBLE', 'PIXEL_REQUIRED',
           'TOUCH_REQUIRED', 'TOUCH_INVALID', 'TOUCH_EXISTING', 'TOUCH_VALID', 'TOUCH_FREE', 'TOUCH_RESOLVING',
           'Design', 'circular_brush', 'notched_square_brush', 'show_mask', 'visualize', 'add_void_touch',
           'take_free_void_touches', 'add_solid_touch', 'take_free_solid_touches']

# Internal Cell
from typing import NamedTuple

import jax
import jax.numpy as jnp
import matplotlib.pyplot as plt
from fastcore.basics import patch_to
from .utils import batch_conv2d, conv2d, dilute
from matplotlib.colors import ListedColormap
from types import SimpleNamespace

# Cell
UNASSIGNED = 0
VOID = 1
SOLID = 2
PIXEL_IMPOSSIBLE = 3
PIXEL_EXISTING = 4
PIXEL_POSSIBLE = 5
PIXEL_REQUIRED = 6
TOUCH_REQUIRED = 7
TOUCH_INVALID = 8
TOUCH_EXISTING = 9
TOUCH_VALID = 10
TOUCH_FREE = 11
TOUCH_RESOLVING = 12

# Cell
class Design(NamedTuple):
    unassigned: jnp.ndarray
    void: jnp.ndarray
    solid: jnp.ndarray
    void_pixel_impossible: jnp.ndarray
    void_pixel_existing: jnp.ndarray
    void_pixel_possible: jnp.ndarray
    void_pixel_required: jnp.ndarray
    solid_pixel_impossible: jnp.ndarray
    solid_pixel_existing: jnp.ndarray
    solid_pixel_possible: jnp.ndarray
    solid_pixel_required: jnp.ndarray
    void_touch_required: jnp.ndarray
    void_touch_invalid: jnp.ndarray
    void_touch_existing: jnp.ndarray
    void_touch_valid: jnp.ndarray
    void_touch_free: jnp.ndarray
    void_touch_resolving: jnp.ndarray
    solid_touch_required: jnp.ndarray
    solid_touch_invalid: jnp.ndarray
    solid_touch_existing: jnp.ndarray
    solid_touch_valid: jnp.ndarray
    solid_touch_free: jnp.ndarray
    solid_touch_resolving: jnp.ndarray

    @property
    def shape(self):
        return self.unassigned.shape

    def copy(self, **kwargs):
        kwargs = {name: kwargs.get(name, getattr(self, name)) for name in self._fields}
        return Design(*kwargs.values())

# Cell
def circular_brush(diameter):
    radius = diameter / 2
    X, Y = jnp.mgrid[-radius:radius:1j*diameter,-radius:radius:1j*diameter]
    _int = lambda x: jnp.array(x, dtype=int)
    brush = _int(X)**2 + _int(Y)**2 < radius**2
    return brush

# Cell
def notched_square_brush(width, notch):
    Z = jnp.ones((width, width), dtype=bool)
    notch = abs(notch)
    if notch > 0:
        Z = Z.at[:notch,:notch].set(False)
        Z = Z.at[:notch,-notch:].set(False)
        Z = Z.at[-notch:,:notch].set(False)
        Z = Z.at[-notch:,-notch:].set(False)
    return Z

# Cell
def show_mask(brush):
    nx, ny = brush.shape
    _cmap = ListedColormap(colors={0: "#ffffff", 1: "#929292"}.values())
    ax = plt.gca()
    ax.set_yticks(jnp.arange(nx)+0.5, ["" for i in range(nx)])
    ax.set_xticks(jnp.arange(ny)+0.5, ["" for i in range(ny)])
    ax.set_yticks(jnp.arange(nx), [f"{i}" for i in range(nx)], minor=True)
    ax.set_xticks(jnp.arange(ny), [f"{i}" for i in range(ny)], minor=True)
    plt.grid(True, color='k')
    plt.imshow(brush, cmap=_cmap)

# Cell
def visualize(design):
    zero = jnp.zeros_like(design.unassigned, dtype=jnp.uint8)
    design_vis = dict(
        design=zero.at[design.unassigned].set(UNASSIGNED).at[design.void].set(VOID).at[design.solid].set(SOLID),
        void_pixels=zero.at[design.void_pixel_possible].set(PIXEL_POSSIBLE).at[design.void_pixel_impossible].set(PIXEL_IMPOSSIBLE).at[design.void_pixel_existing].set(PIXEL_EXISTING).at[design.void_pixel_required].set(PIXEL_REQUIRED),
        solid_pixels=zero.at[design.solid_pixel_possible].set(PIXEL_POSSIBLE).at[design.solid_pixel_impossible].set(PIXEL_IMPOSSIBLE).at[design.solid_pixel_existing].set(PIXEL_EXISTING).at[design.solid_pixel_required].set(PIXEL_REQUIRED),
        void_touches=zero.at[design.void_touch_valid].set(TOUCH_VALID).at[design.void_touch_invalid].set(TOUCH_INVALID).at[design.void_touch_existing].set(TOUCH_EXISTING).at[design.void_touch_free].set(TOUCH_FREE).at[design.void_touch_resolving].set(TOUCH_RESOLVING),
        solid_touches=zero.at[design.solid_touch_valid].set(TOUCH_VALID).at[design.solid_touch_invalid].set(TOUCH_INVALID).at[design.solid_touch_existing].set(TOUCH_EXISTING).at[design.solid_touch_free].set(TOUCH_FREE).at[design.solid_touch_resolving].set(TOUCH_RESOLVING),
    )
    nx, ny = design.shape
    _cmap = ListedColormap(colors={UNASSIGNED: "#929292", VOID: "#cbcbcb", SOLID: "#515151", PIXEL_IMPOSSIBLE: "#8dd3c7", PIXEL_EXISTING: "#ffffb3", PIXEL_POSSIBLE: "#bebada", PIXEL_REQUIRED: "#fb7f72", TOUCH_REQUIRED: "#00ff00", TOUCH_INVALID: "#7fb1d3", TOUCH_EXISTING: "#fdb462", TOUCH_VALID: "#b3de69", TOUCH_FREE: "#fccde5", TOUCH_RESOLVING: "#e0e0e0"}.values(), name="cmap")
    fig, axs = plt.subplots(1, 5, figsize=(15,3*nx/ny))
    for i, (title, arr) in enumerate(design_vis.items()):
        ax = axs[i]
        ax.set_title(title.replace("_", " "))
        ax.imshow(arr, cmap=_cmap, vmin=UNASSIGNED, vmax=TOUCH_RESOLVING)
        ax.set_yticks(jnp.arange(nx)+0.5, ["" for i in range(nx)])
        ax.set_xticks(jnp.arange(ny)+0.5, ["" for i in range(ny)])
        ax.set_yticks(jnp.arange(nx), [f"{i}" for i in range(nx)], minor=True)
        ax.set_xticks(jnp.arange(ny), [f"{i}" for i in range(ny)], minor=True)
        ax.set_xlim(-0.5, ny-0.5)
        ax.set_ylim(nx-0.5, -0.5)
        ax.grid(visible=True, which="major", c="k")

@patch_to(Design)
def _repr_html_(self):
    visualize(self)
    return ""

# Cell

@jax.jit
def _find_free_touches(touches_mask, pixels_mask, brush):
    r = jnp.zeros_like(touches_mask, dtype=bool)
    m, n = r.shape
    i, j = jnp.arange(m), jnp.arange(n)
    I, J = [idxs.ravel() for idxs in jnp.meshgrid(i, j)]
    K = jnp.arange(m * n)
    R = jnp.broadcast_to(r[None, :, :], (m * n, m, n)).at[K, I, J].set(True)
    Rb = batch_conv2d(R, brush[None]) | pixels_mask
    free_idxs = (Rb == pixels_mask).all((1, 2))
    free_touches_mask = jnp.where(free_idxs[:, None, None], R, 0).sum(0, dtype=bool)
    return free_touches_mask ^ touches_mask


@jax.jit
def _find_required_pixels(pixel_map, brush):
    mask = (~pixel_map) & (~dilute(pixel_map, brush))
    return ~(dilute(mask, brush) | pixel_map)


@jax.jit
def add_void_touch(design, brush, pos):
    if isinstance(pos, tuple):
        void_touch_existing = design.void_touch_existing.at[pos[0], pos[1]].set(True)
    else:
        assert pos.dtype == bool
        void_touch_existing = pos | (design.void_touches == TOUCH_EXISTING)
    void_pixel_mask = dilute(void_touch_existing, brush) | (design.design == VOID)
    required_void_pixel_mask = _find_required_pixels(void_pixel_mask, brush)
    diluted_mask = dilute(void_pixel_mask, brush)
    design_ = jnp.where(void_pixel_mask, VOID, design.design)
    void_touches_free = _find_free_touches(void_touch_existing, void_pixel_mask | required_void_pixel_mask, brush)
    void_touches = jnp.where(design.void_touches == TOUCH_RESOLVING, TOUCH_VALID, design.void_touches)
    void_touches = jnp.where(void_touch_existing, TOUCH_EXISTING, void_touches)
    void_touches = jnp.where(void_touches_free, TOUCH_FREE, void_touches)
    resolving_pixels = jnp.where(void_touches == TOUCH_VALID, dilute(required_void_pixel_mask, brush), False)
    void_touches = jnp.where(resolving_pixels, TOUCH_RESOLVING, void_touches)
    void_pixels = jnp.where(void_pixel_mask, PIXEL_EXISTING, design.void_pixels)
    void_pixels = jnp.where(required_void_pixel_mask, PIXEL_REQUIRED, void_pixels)
    solid_pixels =  jnp.where(void_pixel_mask, PIXEL_IMPOSSIBLE, design.solid_pixels)
    solid_pixels = jnp.where(required_void_pixel_mask, PIXEL_IMPOSSIBLE, solid_pixels)
    solid_touches = jnp.where(diluted_mask, TOUCH_INVALID, design.solid_touches)
    return Design(design_, void_pixels, solid_pixels, void_touches, solid_touches)

# Cell
@jax.jit
def take_free_void_touches(design, brush):
    # originally:
    # design = design.copy(void_touches=jnp.where(design.void_touches == TOUCH_FREE, TOUCH_EXISTING, design.void_touches))
    # â¬† the above solution is not good. It does not resolve required touches if present, we need to actually use the brush:
    free_touches_mask = (design.void_touches == TOUCH_FREE)
    return add_void_touch(design, brush, free_touches_mask)

# Cell

@jax.jit
def add_solid_touch(design, brush, pos):
    if isinstance(pos, tuple):
        solid_touches_mask = design.solid_touches.at[pos[0], pos[1]].set(TOUCH_EXISTING) == TOUCH_EXISTING
    else:
        assert pos.dtype == bool
        solid_touches_mask = pos | (design.solid_touches == TOUCH_EXISTING)
    solid_pixel_mask = dilute(solid_touches_mask, brush) | (design.design == SOLID)
    required_solid_pixel_mask = _find_required_pixels(solid_pixel_mask, brush)
    diluted_mask = dilute(solid_pixel_mask, brush)
    design_ = jnp.where(solid_pixel_mask, SOLID, design.design)
    free_solid_touches_mask = _find_free_touches(solid_touches_mask, solid_pixel_mask | required_solid_pixel_mask, brush)
    solid_touches = jnp.where(design.solid_touches == TOUCH_RESOLVING, TOUCH_VALID, design.solid_touches)
    solid_touches = jnp.where(solid_touches_mask, TOUCH_EXISTING, solid_touches)
    solid_touches = jnp.where(free_solid_touches_mask, TOUCH_FREE, solid_touches)
    resolving_pixels = jnp.where(solid_touches == TOUCH_VALID, dilute(required_solid_pixel_mask, brush), False)
    solid_touches = jnp.where(resolving_pixels, TOUCH_RESOLVING, solid_touches)
    solid_pixels = jnp.where(solid_pixel_mask, PIXEL_EXISTING, design.solid_pixels)
    solid_pixels = jnp.where(required_solid_pixel_mask, PIXEL_REQUIRED, solid_pixels)
    void_pixels =  jnp.where(solid_pixel_mask, PIXEL_IMPOSSIBLE, design.void_pixels)
    void_pixels = jnp.where(required_solid_pixel_mask, PIXEL_IMPOSSIBLE, void_pixels)
    void_touches = jnp.where(diluted_mask, TOUCH_INVALID, design.void_touches)
    return Design(design_, void_pixels, solid_pixels, void_touches, solid_touches)

# Cell
@jax.jit
def take_free_solid_touches(design, brush):
    free_touches_mask = (design.solid_touches == TOUCH_FREE)
    return add_solid_touch(design, brush, free_touches_mask)