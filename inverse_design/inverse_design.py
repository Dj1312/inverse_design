# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/10_inverse_design_local.ipynb.

# %% auto 0
__all__ = ['omega', 'dl', 'Nx', 'Ny', 'Npml', 'epsr_init', 'space', 'wg_width', 'space_slice', 'Nsteps', 'step_size', 'epsr',
           'bg_epsr', 'design_region', 'input_slice', 'output_slice', 'epsr_total', 'source', 'probe', 'debug_forward',
           'grad_fn', 'jax_grad', 'forward', 'loss_fn', 'loss_jax', 'loss_jax_jvp', 'step_fn']

# %% ../notebooks/10_inverse_design_local.ipynb 2
import autograd.numpy as npa
import jax
import jax.numpy as jnp
import matplotlib.pylab as plt
import numpy as np
from ceviche import jacobian
from ceviche.modes import insert_mode
from inverse_design.brushes import notched_square_brush, show_mask
from inverse_design.conditional_generator import (
    new_latent_design,
    transform,
)
from inverse_design.local_generator import (
    generate_feasible_design,
    generate_feasible_design_mask
)
from inverse_design.direct_optimization import huber_loss
from inverse_design.naive_inverse_design import (
    init_domain,
    mask_combine_epsr,
    mode_overlap,
    viz_sim,
)
from jax.example_libraries.optimizers import adam
from tqdm.notebook import trange

# %% ../notebooks/10_inverse_design_local.ipynb 5
# Angular frequency of the source in Hz
omega = 2 * np.pi * 200e12
# Spatial resolution in meters
dl = 40e-9
# Number of pixels in x-direction
Nx = 120
# Number of pixels in y-direction
Ny = 120
# Number of pixels in the PMLs in each direction
Npml = 20
# Initial value of the structure's relative permittivity
epsr_init = 12.0
# Space between the PMLs and the design region (in pixels)
space = 10
# Width of the waveguide (in pixels)
wg_width = 12
# Length in pixels of the source/probe slices on each side of the center point
space_slice = 8
# Number of epochs in the optimization
Nsteps = 100
# Step size for the Adam optimizer
step_size = 1e-2

# %% ../notebooks/10_inverse_design_local.ipynb 9
# Initialize the parametrization rho and the design region
epsr, bg_epsr, design_region, input_slice, output_slice = init_domain(
    Nx, Ny, Npml, space=space, wg_width=wg_width, space_slice=space_slice
)

epsr_total = mask_combine_epsr(epsr, bg_epsr, design_region)

# Setup source
source = insert_mode(omega, dl, input_slice.x, input_slice.y, epsr_total, m=1)

# Setup probe
probe = insert_mode(omega, dl, output_slice.x, output_slice.y, epsr_total, m=2)

# %% ../notebooks/10_inverse_design_local.ipynb 19
def forward(latent_weights, brush):
    latent_t = transform(latent_weights, brush)
    design_mask = generate_feasible_design_mask(latent_t, brush)
    epsr = jnp.where(design_mask>0, 12.0, 1.0)
    return epsr

# %% ../notebooks/10_inverse_design_local.ipynb 21
def loss_fn(epsr):
    simulation.eps_r = mask_combine_epsr(epsr, bg_epsr, design_region)
    _, _, Ez = simulation.solve(source)
    return -mode_overlap(Ez, probe) / E0

# %% ../notebooks/10_inverse_design_local.ipynb 22
debug_forward=True
@jax.custom_jvp
def loss_jax(latent):
  eps = forward(latent.reshape((Nx, Ny)), brush)
  if debug_forward:
    plt.figure(figsize=(0.5,0.5), frameon=False)
    plt.imshow(eps)
    plt.axis("off")
    plt.show()
  #eps = np.asarray(eps, dtype=float)
  return loss_fn(eps)

grad_fn = jacobian(loss_fn, mode='reverse')

@loss_jax.defjvp
def loss_jax_jvp(primals, tangents):
  latent = primals[0].reshape((Nx, Ny))
  primals_out = loss_jax(latent)
  latent = np.asarray(latent, dtype=float)
  g = jnp.array(grad_fn(latent))
  
  return primals_out, jnp.dot(g[0],tangents[0][0])  # why does this work?!

jax_grad = jax.value_and_grad(loss_jax)

# %% ../notebooks/10_inverse_design_local.ipynb 27
def step_fn(step, state):
    latent = params_fn(state) # we need autograd arrays here...
    loss, grads = jax_grad(latent)
    optim_state = update_fn(step, grads, state)
    return loss, optim_state
